import { expect, describe, vi, it } from "vitest";
import { SVOX } from "../src/index";

const voxDataEmptyPalette = new Uint8Array([
	86, 79, 88, 32, 200, 0, 0, 0, 77, 65, 73, 78, 0, 0, 0, 0, 60, 4, 0, 0, 83, 73, 90, 69, 12, 0, 0,
	0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 88, 89, 90, 73, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0,
	0, 0, 0, 0, 0, 8, 0, 0, 2, 1, 82, 71, 66, 65, 0, 4, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0,
	255, 0, 0, 0, 255, 0, 0, 0, 0,
]);

const voxData = new Uint8Array([
	86, 79, 88, 32, 200, 0, 0, 0, 77, 65, 73, 78, 0, 0, 0, 0, 56, 4, 0, 0, 83, 73, 90, 69, 12, 0, 0,
	0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 88, 89, 90, 73, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0,
	0, 0, 0, 0, 0, 246, 82, 71, 66, 65, 0, 4, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 204,
	255, 255, 255, 153, 255, 255, 255, 102, 255, 255, 255, 51, 255, 255, 255, 0, 255, 255, 204, 255,
	255, 255, 204, 204, 255, 255, 204, 153, 255, 255, 204, 102, 255, 255, 204, 51, 255, 255, 204, 0,
	255, 255, 153, 255, 255, 255, 153, 204, 255, 255, 153, 153, 255, 255, 153, 102, 255, 255, 153, 51,
	255, 255, 153, 0, 255, 255, 102, 255, 255, 255, 102, 204, 255, 255, 102, 153, 255, 255, 102, 102,
	255, 255, 102, 51, 255, 255, 102, 0, 255, 255, 51, 255, 255, 255, 51, 204, 255, 255, 51, 153, 255,
	255, 51, 102, 255, 255, 51, 51, 255, 255, 51, 0, 255, 255, 0, 255, 255, 255, 0, 204, 255, 255, 0,
	153, 255, 255, 0, 102, 255, 255, 0, 51, 255, 255, 0, 0, 255, 204, 255, 255, 255, 204, 255, 204,
	255, 204, 255, 153, 255, 204, 255, 102, 255, 204, 255, 51, 255, 204, 255, 0, 255, 204, 204, 255,
	255, 204, 204, 204, 255, 204, 204, 153, 255, 204, 204, 102, 255, 204, 204, 51, 255, 204, 204, 0,
	255, 204, 153, 255, 255, 204, 153, 204, 255, 204, 153, 153, 255, 204, 153, 102, 255, 204, 153, 51,
	255, 204, 153, 0, 255, 204, 102, 255, 255, 204, 102, 204, 255, 204, 102, 153, 255, 204, 102, 102,
	255, 204, 102, 51, 255, 204, 102, 0, 255, 204, 51, 255, 255, 204, 51, 204, 255, 204, 51, 153, 255,
	204, 51, 102, 255, 204, 51, 51, 255, 204, 51, 0, 255, 204, 0, 255, 255, 204, 0, 204, 255, 204, 0,
	153, 255, 204, 0, 102, 255, 204, 0, 51, 255, 204, 0, 0, 255, 153, 255, 255, 255, 153, 255, 204,
	255, 153, 255, 153, 255, 153, 255, 102, 255, 153, 255, 51, 255, 153, 255, 0, 255, 153, 204, 255,
	255, 153, 204, 204, 255, 153, 204, 153, 255, 153, 204, 102, 255, 153, 204, 51, 255, 153, 204, 0,
	255, 153, 153, 255, 255, 153, 153, 204, 255, 153, 153, 153, 255, 153, 153, 102, 255, 153, 153, 51,
	255, 153, 153, 0, 255, 153, 102, 255, 255, 153, 102, 204, 255, 153, 102, 153, 255, 153, 102, 102,
	255, 153, 102, 51, 255, 153, 102, 0, 255, 153, 51, 255, 255, 153, 51, 204, 255, 153, 51, 153, 255,
	153, 51, 102, 255, 153, 51, 51, 255, 153, 51, 0, 255, 153, 0, 255, 255, 153, 0, 204, 255, 153, 0,
	153, 255, 153, 0, 102, 255, 153, 0, 51, 255, 153, 0, 0, 255, 102, 255, 255, 255, 102, 255, 204,
	255, 102, 255, 153, 255, 102, 255, 102, 255, 102, 255, 51, 255, 102, 255, 0, 255, 102, 204, 255,
	255, 102, 204, 204, 255, 102, 204, 153, 255, 102, 204, 102, 255, 102, 204, 51, 255, 102, 204, 0,
	255, 102, 153, 255, 255, 102, 153, 204, 255, 102, 153, 153, 255, 102, 153, 102, 255, 102, 153, 51,
	255, 102, 153, 0, 255, 102, 102, 255, 255, 102, 102, 204, 255, 102, 102, 153, 255, 102, 102, 102,
	255, 102, 102, 51, 255, 102, 102, 0, 255, 102, 51, 255, 255, 102, 51, 204, 255, 102, 51, 153, 255,
	102, 51, 102, 255, 102, 51, 51, 255, 102, 51, 0, 255, 102, 0, 255, 255, 102, 0, 204, 255, 102, 0,
	153, 255, 102, 0, 102, 255, 102, 0, 51, 255, 102, 0, 0, 255, 51, 255, 255, 255, 51, 255, 204, 255,
	51, 255, 153, 255, 51, 255, 102, 255, 51, 255, 51, 255, 51, 255, 0, 255, 51, 204, 255, 255, 51,
	204, 204, 255, 51, 204, 153, 255, 51, 204, 102, 255, 51, 204, 51, 255, 51, 204, 0, 255, 51, 153,
	255, 255, 51, 153, 204, 255, 51, 153, 153, 255, 51, 153, 102, 255, 51, 153, 51, 255, 51, 153, 0,
	255, 51, 102, 255, 255, 51, 102, 204, 255, 51, 102, 153, 255, 51, 102, 102, 255, 51, 102, 51, 255,
	51, 102, 0, 255, 51, 51, 255, 255, 51, 51, 204, 255, 51, 51, 153, 255, 51, 51, 102, 255, 51, 51,
	51, 255, 51, 51, 0, 255, 51, 0, 255, 255, 51, 0, 204, 255, 51, 0, 153, 255, 51, 0, 102, 255, 51,
	0, 51, 255, 51, 0, 0, 255, 0, 255, 255, 255, 0, 255, 204, 255, 0, 255, 153, 255, 0, 255, 102, 255,
	0, 255, 51, 255, 0, 255, 0, 255, 0, 204, 255, 255, 0, 204, 204, 255, 0, 204, 153, 255, 0, 204,
	102, 255, 0, 204, 51, 255, 0, 204, 0, 255, 0, 153, 255, 255, 0, 153, 204, 255, 0, 153, 153, 255,
	0, 153, 102, 255, 0, 153, 51, 255, 0, 153, 0, 255, 0, 102, 255, 255, 0, 102, 204, 255, 0, 102,
	153, 255, 0, 102, 102, 255, 0, 102, 51, 255, 0, 102, 0, 255, 0, 51, 255, 255, 0, 51, 204, 255, 0,
	51, 153, 255, 0, 51, 102, 255, 0, 51, 51, 255, 0, 51, 0, 255, 0, 0, 255, 255, 0, 0, 204, 255, 0,
	0, 153, 255, 0, 0, 102, 255, 0, 0, 51, 255, 238, 0, 0, 255, 221, 0, 0, 255, 187, 0, 0, 255, 170,
	0, 0, 255, 136, 0, 0, 255, 119, 0, 0, 255, 85, 0, 0, 255, 68, 0, 0, 255, 34, 0, 0, 255, 17, 0, 0,
	255, 0, 238, 0, 255, 0, 221, 0, 255, 0, 187, 0, 255, 0, 170, 0, 255, 0, 136, 0, 255, 0, 119, 0,
	255, 0, 85, 0, 255, 0, 68, 0, 255, 0, 34, 0, 255, 0, 17, 0, 255, 0, 0, 238, 255, 0, 0, 221, 255,
	0, 0, 187, 255, 0, 0, 170, 255, 0, 0, 136, 255, 0, 0, 119, 255, 0, 0, 85, 255, 0, 0, 68, 255, 0,
	0, 34, 255, 0, 0, 17, 255, 255, 255, 255, 255, 221, 221, 221, 255, 187, 187, 187, 255, 170, 170,
	170, 255, 136, 136, 136, 255, 119, 119, 119, 255, 85, 85, 85, 255, 68, 68, 68, 255, 34, 34, 34,
	255, 17, 17, 17, 255, 0, 0, 0, 0,
]);

const svoxTestData = [83, 86, 79, 88, 32, 1, 1, 1, 0, 255, 0, 0, 255, 0, 0, 0, 0];
const parsedSvoxDataObj = {
	preamble: {
		magic: "SVOX ",
		version: 1,
		paletteAmount: 1,
		voxelAmount: 1,
	},
	palette: [{ i: 0, r: 255, g: 0, b: 0, a: 255 }],
	voxels: [{ x: 0, y: 0, z: 0, i: 0 }],
};
let svoxDataObj = {
	palette: [{ i: 0, r: 255, g: 0, b: 0, a: 255 }],
	voxels: [{ x: 0, y: 0, z: 0, i: 0 }],
};

describe("fromSVOX", () => {
	it("is defined", () => {
		expect(SVOX.fromSVOX).toBeDefined();
	});

	it("parses svox header", () => {
		expect(SVOX.fromSVOX(new DataView(new Uint8Array(svoxTestData).buffer), true)).toStrictEqual({
			magic: "SVOX ",
			version: 1,
			paletteAmount: 1,
			voxelAmount: 1,
		});
	});

	it("parses svox data successfully", () => {
		expect(SVOX.fromSVOX(new DataView(new Uint8Array(svoxTestData).buffer))).toStrictEqual(
			parsedSvoxDataObj
		);
	});

	it("throws error when only palette amount header field is zero", () => {
		expect(() =>
			SVOX.fromSVOX(new DataView(new Uint8Array([83, 86, 79, 88, 32, 1, 0, 1]).buffer))
		).toThrowError();
	});

	it("throws error when only voxel amount header field is zero", () => {
		expect(() =>
			SVOX.fromSVOX(new DataView(new Uint8Array([83, 86, 79, 88, 32, 1, 1, 0]).buffer))
		).toThrowError();
	});

	it("only parses the header when both amount header fields are zero", () => {
		expect(
			SVOX.fromSVOX(new DataView(new Uint8Array([83, 86, 79, 88, 32, 1, 0, 0]).buffer))
		).toStrictEqual({
			magic: "SVOX ",
			version: 1,
			paletteAmount: 0,
			voxelAmount: 0,
		});
	});

	it("throws error when empty file", () => {
		expect(() => SVOX.fromSVOX(new DataView(new Uint8Array([0]).buffer))).toThrowError();
	});

	it("throws error when header is cutoff", () => {
		expect(() =>
			SVOX.fromSVOX(new DataView(new Uint8Array([83, 86, 79, 88, 32, 1, 0]).buffer))
		).toThrowError();
	});

	it("throws error when voxelChunk is cutoff", () => {
		expect(() =>
			SVOX.fromSVOX(
				new DataView(new Uint8Array([83, 86, 79, 88, 32, 1, 1, 1, 0, 255, 0, 0, 255]).buffer)
			)
		).toThrowError();
	});

	it("throws error when paletteChunk is cutoff", () => {
		expect(() =>
			SVOX.fromSVOX(new DataView(new Uint8Array([83, 86, 79, 88, 32, 1, 1, 1, 0, 255, 0]).buffer))
		).toThrowError();
	});

	it("works for ArrayBufferAlike datastructures", () => {
		//DataView | ArrayBuffer | Buffer | Uint8Array
		expect(SVOX.fromSVOX(new DataView(new Uint8Array(svoxTestData).buffer))).toStrictEqual(
			parsedSvoxDataObj
		);
		expect(SVOX.fromSVOX(new Uint8Array(svoxTestData))).toStrictEqual(parsedSvoxDataObj);
		expect(SVOX.fromSVOX(new Uint8Array(svoxTestData).buffer)).toStrictEqual(parsedSvoxDataObj);
		expect(SVOX.fromSVOX(Buffer.from(svoxTestData))).toStrictEqual(parsedSvoxDataObj);
		//@ts-ignore
		expect(() => SVOX.fromSVOX("thisIsWrong")).toThrowError();
		//@ts-ignore
		expect(() => SVOX.fromSVOX(undefined)).toThrowError();
		//@ts-ignore
		expect(() => SVOX.fromSVOX(null)).toThrowError();
	});
});

describe("fromVOX", () => {
	it("is defined", () => {
		expect(SVOX.fromVOX).toBeDefined();
	});
	it("parses a vox file", () => {
		expect(SVOX.fromVOX(voxDataEmptyPalette.buffer)).toStrictEqual({
			voxels: [
				{ x: 0, y: 0, z: 0, i: 8 },
				{ x: 0, y: 0, z: 2, i: 1 },
			],
			palette: [
				{ i: 1, r: 0, g: 0, b: 0, a: 255 },
				{ i: 8, r: 0, g: 0, b: 0, a: 255 },
			],
		});
	});
	it("throws when input is an empty buffer", () => {
		expect(() => SVOX.fromVOX(new Uint8Array([]).buffer)).toThrowError();
	});
	it("works for ArrayBufferAlike datastructures", () => {
		//DataView | ArrayBuffer | Buffer | Uint8Array
		expect(SVOX.fromSVOX(new DataView(new Uint8Array(svoxTestData).buffer))).toStrictEqual(
			parsedSvoxDataObj
		);
		expect(SVOX.fromSVOX(new Uint8Array(svoxTestData))).toStrictEqual(parsedSvoxDataObj);
		expect(SVOX.fromSVOX(new Uint8Array(svoxTestData).buffer)).toStrictEqual(parsedSvoxDataObj);
		expect(SVOX.fromSVOX(Buffer.from(svoxTestData))).toStrictEqual(parsedSvoxDataObj);
		//@ts-ignore
		expect(() => SVOX.fromSVOX("thisIsWrong")).toThrowError();
		//@ts-ignore
		expect(() => SVOX.fromSVOX(undefined)).toThrowError();
		//@ts-ignore
		expect(() => SVOX.fromSVOX(null)).toThrowError();
	});
});

describe("toSVOX", () => {
	it("is defined", () => {
		expect(SVOX.toSVOX).toBeDefined();
	});
	it("creates the right data from an SVOXGroup", () => {
		expect(SVOX.toSVOX(svoxDataObj)).toStrictEqual(new Uint8Array(svoxTestData));
	});

	it("creates the right data from an empty SVOXGroup", () => {
		expect(SVOX.toSVOX({ voxels: [], palette: [] })).toStrictEqual(
			new Uint8Array([83, 86, 79, 88, 32, 1, 0, 0])
		);
	});

	it("creates the right data from an empty Object", () => {
		//@ts-ignore
		expect(() => SVOX.toSVOX({})).toThrowError();
	});
});
